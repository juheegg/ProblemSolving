## 거짓말

| 날짜     | 분류 | 번호  | 알고리즘 분류 |                                               |
| -------- | ---- | ----- | ------------- | --------------------------------------------- |
| 20-12-12 | 백준 | 1043 | bfs / disjoint | [링크](https://www.acmicpc.net/problem/20165) |

<br/>  

---

<br/>

### 문제 요약 

1. 진실을 아는 사람이 아무도 없는 파티의 수 구하기
2. 진실을 아는 사람이 참여한 파티에서는 진실만 말해야 하기 때문에 해당 파티의 참석자는 모두 진실을 알게됨
3. 또 다른 파티에 진실을 알게된 사람이 참여하면 이 파티에서도 진실을 말해야 함


<br/>

### 풀이

#### bfs
1. 같은 파티에 참석하는 사람들은 인접한다고 침
2. 처음에 주어진 진실을 아는 사람들을 que에 넣고 bfs로 탐색하며 방문한 사람을 체크
3. 모든 파티의 첫번째 사람만 확인
	1. 첫번째 사람이 진실을 알지 못하면 해당 파티에는 진실을 모르는 사람들만 참여한 것이므로 answr++

#### disjoint
1. 파티에 참여하는 사람이 아닌 이외의 0번을 추가
2. 0번을 root로 처음에 주어진 진실을 아는 사람들을 union함
3. 각각의 파티 사람들을 union
4. 모든 파티의 첫번째 사람만 확인
	1. 첫번째 사람의 parent가 0이 아니면 진실을 모르는 사람들만 참여한 파티이므로 answer++;


<br/>

### 비고
- 각 노드에 번호가 주어질 경우 **1부터 시작하는 경우**가 많으니까 배열을 만들 때 N+1 해야하는지 아닌지 반드시 확인

<br />

### sudo
int N, M  
List<Integer> party[M]  
int truth[]  
boolean adj[N*N]  
boolean visit[N]  
  
for(i 0~M-1)  
	for(j 0~party.size()-2)  
		for(k j+1~party.size()-1)  
			adj[j,k] = true  
  
queue에 thruth 전부 넣어   
bfs  

for(i 0~M-1)  
	party[i].get(0)에 visit이 false이면 answer++  
