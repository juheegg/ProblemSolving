## 연예인은 힘들어

| 날짜   | 분류 | 번호 | 알고리즘 분류 |                                          |
| ------ | ---- | ---- | ------------- | ---------------------------------------- |
| 20-12-14 | 백준 | 17270 | 다익스트라 | [링크](https://www.acmicpc.net/problem/17270) |

<br/><br/>

### 문제 요약 

1. J에서 S로 가는 경로들 중 조건에 맞는 노드 찾기
2. 조건
   1. J와 S는 제외
   2. J~S 경로는 거리가 최소여야 함 - J->노드 거리와 S->노드 거리 합
   3. J->노드의 길이는 S->노드의 길이보다 작거나 같아야 함
   4. 1~3을 만족하는 노드가 여러개일 경우, J->노드의 길이가 가장 짧은 노드
   5. 1~4를 만족하는 노드가 여러개일 경우, 노드의 번호가 가장 작은 노드
3. 양방향 간선, J와 S는 반드시 이어져 있음
4. 조건을 모두 만족하는 노드가 없을 경우 -1 반환


<br/>

### 풀이

1. J와 S 각각에서 모든 노드로 가는 최단 거리 찾기 (다익스트라 사용)
2. J->노드 거리와 S->노드 거리 합의 최소 (tot) 찾기
3. 1번 노드부터 V번 노드까지 for문
   1. i가 J나 S면 continue
   2. J->i->S의 거리가 tot과 다르면 continue
   3. J->i 거리가 S->i보다 크면 continue
   4. 지금까지 저장한 min 값보다 작은 J-> 값이 나오면 min 값과 index 값 업데이트  
   min값과 같은 경우 업데이트 할 경우, 노드의 번호가 커져서 안됨  

<br/>

### 비고

- 최단 경로를 Jdis[S] (다익스트라로 구한 J에서 S로 가는 최단경로)로 놓으면 안됨! 
   - J와 S가 연결되어 있을 경우 이 경로가 가장 작을 수 있기 때문
- 운 좋게 예외 테케를 생각해내서 풀 수 있었음 ㅠㅠ
```text
3 3
1 2 1
2 3 7
1 3 1
1 2
``` 

<br/>

### sudo

```java
class Edge - int a, b, w
int V, M
List<Edge> adj
int J, S

int Jmin[V], Smin[V]
int tot
getDijkstra J, S

int jdis = INF
for(0 <= i < V)
	if(i == J or S)
		continue
	if( Jmin[i]+Smin[i] == tot && Jmin[i] < Jdis )
		answer = i
		Jdis = Jmin[i]


```